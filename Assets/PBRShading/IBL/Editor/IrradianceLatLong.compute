// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel IrradianceLatLong

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2DArray<float4> _OutArray;
TextureCube<float3> _EnvCube;
SamplerState sampler_EnvCube;
int2 _TextureSize;

// 输出面 (face, uv∈[-1,1]) -> 世界方向 N（Cubemap 标准）
float3 FaceUvToDir(uint face, float2 uv)
{
    float x = uv.x;
    float y = uv.y;
    // 注意：不同引擎/平台对面朝向略有差异，保持一致即可
    // 这个地方为什么这么做是对的，就是构造出了一个方向向量，刚好终点在每个面上，再做normalized
    if (face == 0)   return normalize(float3( 1,   -y,  -x)); // +X
    else if (face==1)return normalize(float3(-1,   -y,   x)); // -X
    else if (face==2)return normalize(float3( x,    1,   y)); // +Y
    else if (face==3)return normalize(float3( x,   -1,  -y)); // -Y
    else if (face==4)return normalize(float3( x,   -y,   1)); // +Z
    else             return normalize(float3(-x,   -y,  -1)); // -Z
}

[numthreads(8,8,1)]
void IrradianceLatLong (uint3 SV_GroupID        : SV_GroupID,
            uint3 SV_GroupThreadID  : SV_GroupThreadID,
            uint  SV_GroupIndex     : SV_GroupIndex,
            uint3 SV_DispatchThreadID : SV_DispatchThreadID)
{
    // UVx就是x方向 0 ~ 1
    // UVy就是y方向 0 ~ 1
    
    int UVx = SV_DispatchThreadID.x;
    int UVy = SV_DispatchThreadID.y;
    // 将uv -> -1 ~ 1
    float2 uv = float2(UVx/(float)_TextureSize.x, UVy/(float)_TextureSize.y) * 2 - 1.0;
    int face = SV_GroupID.z;
    // 1. 首先生成法线方向:
    float3 N = FaceUvToDir(face, uv);
    float3 irradiance = 0;
    // tangent space calculation from origin point
    // 从法线方向构建坐标，在世界空间中，因为生成的法线在世界空间中
    float3 up    = float3(0.0, 1.0, 0.0);
    float3 right = normalize(cross(up, N));
    up         = normalize(cross(N, right));
    float sampleDelta = 0.008;
    float nrSamples = 0.0;

    // 产生黎曼和， 0~2PI ，  0~0.5PI，方向上积分。
    for(float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta)
    {
        for(float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta)
        {
            // spherical to cartesian (in tangent space)
            float3 tangentSample = float3(sin(theta) * cos(phi),  sin(theta) * sin(phi), cos(theta));
            // tangent space to world
            // 构建向量然后从tangent space转到直接坐标，比如这个向量原先是normal为z轴的，
            // 把Normal拆成xyz三个方向了，相当于把向量从切线空间 -> 世界空间，
            float3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * N; 

            irradiance +=  SAMPLE_TEXTURECUBE_LOD(_EnvCube, sampler_EnvCube, sampleVec, 3).rgb * cos(theta) * sin(theta);
            nrSamples++;
        }
    }

    irradiance = PI * irradiance * (1.0 / float(nrSamples));
    _OutArray[uint3(UVx, UVy,face)] = float4(irradiance, 1.0);

    
}
